using System;
using System.Threading.Tasks;
using PixelPuzzle.Contexts;
using PixelPuzzle.Controls;
using PixelPuzzle.Logic;

namespace PixelPuzzle.Screens.Puzzle {
    public class PuzzleScreenViewModel : ViewModelBase {
        private readonly Level level;

        public PuzzleControlViewModel PuzzleControlViewModel { get; }

        public string LevelNumber {
            get {
                var levelCount = Context.Model.GetLevels(level.Difficulty).Count;

                return $"{level.LevelNumber}/{levelCount}";
            }
        }

        public bool IsComplete => level.IsComplete;

        public Difficulty Difficulty => level.Difficulty;

        public PuzzleScreenViewModel(MainContext context, Level level) : base(context) {
            this.level = level;

            PuzzleControlViewModel = new PuzzleControlViewModel(context, level.Map, true);
            PuzzleControlViewModel.Game.GameCompleted += Game_GameCompleted;

            if (level.UserMap != null) {
                PuzzleControlViewModel.Game.ApplyUserValues(level.UserMap);
            }
                PuzzleControlViewModel.Game.Solve(); // temp REMOVE
        }

        private async void Game_GameCompleted(object sender, EventArgs e) {
            OnPropertyChanged(nameof(IsComplete));

            await Context.UI.ShowCompletedModal();
        }

        public async Task SaveGameState() {
            if (level.IsAutoGenerated) {
                return;
            }

            await Context.Model.SaveLevel(
                level.LevelNumber,
                level.Difficulty,
                PuzzleControlViewModel.Game.GetUserMap(),
                PuzzleControlViewModel.Game.IsComplete);
        }

        public void Reset() {
            foreach (var cell in PuzzleControlViewModel.Game.Cells) {
                cell.UserValue = CellValue.Blank;
            }

            level.IsComplete = false;
            level.UserMap = PuzzleControlViewModel.Game.GetUserMap();

            OnPropertyChanged();
        }
    }
}
